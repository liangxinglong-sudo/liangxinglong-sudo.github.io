import{_ as o,c as t,a as r,o as n}from"./app-noM96vtB.js";const a={};function i(l,e){return n(),t("div",null,e[0]||(e[0]=[r('<h3 id="如何处理重复消息" tabindex="-1"><a class="header-anchor" href="#如何处理重复消息"><span>➡️ 如何处理重复消息</span></a></h3><ul><li><p><strong>重复消息是如何出现的？</strong></p><ol><li>生产者将消息放入<code>Broker</code>等待<code>Broker</code>的响应时，由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了。</li><li>假设消费者拿到消息消费，业务逻辑走完了，事物提交了，此时要更新<code>Consumer offest </code>，然后消费者挂了，另一个消费者顶上，此时<code>Consumer offest</code>没有更新，于是又拿一遍刚才的消息，业务又执行一遍。</li></ol></li><li><p><strong>如何解决重复消费消息？幂等</strong>。</p><ol><li>通过version即版本号控制，对比消息中的版本号和数据库中的版本号</li><li>记录关键的key。如订单ID等。</li></ol><div class="hint-container tip"><p class="hint-container-title">什么是幂等？</p><p>理解为同样的参数多次调用同一个接口和调用一次产生的结果是一致的。</p></div></li></ul><h3 id="如何处理消息堆积" tabindex="-1"><a class="header-anchor" href="#如何处理消息堆积"><span>➡️ 如何处理消息堆积</span></a></h3><ul><li><p><strong>原因</strong></p><p>生产者的生产速度与消费者的速度不匹配。</p></li><li><p><strong>方案</strong></p><p>先定位<strong>消费慢</strong>的原因，如果是bug则处理bug；如果是本身消费能力较弱，优化小消费逻辑，比如之前是一条一条消费处理的，优化为批量处理；水平扩容，增加<code>Topic</code>队列数和消费者数。<strong>注意队列数一定要增加</strong>，不然新增加的消费者是没东西消费的。<strong>一个Topic中，一个队列只会分配给一个消费者</strong>。</p><p>你是将接受到的消息写入内存队列之后，然后就返回响应给<code>Broker</code>，然后多线程向内存队列消费消息，假设此时消费者宕机之后内存队列里还未消费的消息也就丢了。</p></li></ul><h3 id="如何写个消息中间件" tabindex="-1"><a class="header-anchor" href="#如何写个消息中间件"><span>➡️ 如何写个消息中间件</span></a></h3><ol><li><p>首先需要明确地提出 <mark>消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心</mark>。</p></li><li><p>简述下消息中间件数据流转过程，无非就是 <mark>生产者生产消息，发送至Broker，Broker可以暂缓消息，然后消费者再从Broker获取消息，用于消费</mark>。</p></li><li><p>而注册中心用于服务的发现包括：<mark>Broker的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心</mark>。</p></li><li><p>然后开始讲述实现要点： <mark>各个模块的通信基于Netty然后自定义协议来实现</mark> ，注册中心可以利用Zookeeper、consul、eureka、nacos等等，<strong>也可以像RockerMQ自己实现简单的namesrv</strong></p></li><li><p>为了考虑扩容和整体的性能，采用分布式思想，就像<strong>kafka一样采取分区理念</strong>， <mark>一个Topic分为多个partition，并且为了保证数据可靠性，采取多副本存储，即Leader和follower</mark> ，根据性能和数据可靠的权衡提供异步和同步的输盘存储</p></li><li><p>还可以利用 <mark>选举算法保证Leader挂了之后follower可以顶上</mark> ，保证消息队列的高可用</p></li><li><p>为了提供消息的可靠性， <mark>利用本地文件系统来存储消息</mark> ，并且采用顺序写的方式来提高性能</p></li><li><p>根据消息队列的特性 <mark>利用内存映射、零拷贝进一步提升性能</mark> ，<strong>还可以利用像kafka这种批处理思想提高整体的吞吐量</strong>。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">衍生问题</p><ol><li>Netty是什么？各注册中心之间的选型对比？</li></ol><p>2.选举算法，Bully 算法、Raft 算法、ZAB 算法等等？</p><p>3.分区，这个分区和 RocketMQ 的队列有什么不同？具体分区要怎么实现？</p><p>4.顺序写，为什么要顺序写啊？内存映射和零拷贝又是什么啊？RocketMQ 和 Kafka 用了哪个吗?</p><p>5.消息的写入如何存储、消息的索引如何生成等等？有没有看过消息中间件的源码？</p></div>',7)]))}const s=o(a,[["render",i]]),c=JSON.parse('{"path":"/knowledge/component/mq/mq-noMore/","title":"如何处理重复消息","lang":"zh-CN","frontmatter":{"title":"如何处理重复消息","icon":"tabler:message-plus","category":["开发工具"],"tag":["tools"],"createTime":"2025/04/10 17:28:06","permalink":"/knowledge/component/mq/mq-noMore/","description":"➡️ 如何处理重复消息 重复消息是如何出现的？ 生产者将消息放入Broker等待Broker的响应时，由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了。 假设消费者拿到消息消费，业务逻辑走完了，事物提交了，此时要更新Consumer offest ，然后消费者挂了，另一个消费者顶上，此时Consumer offest没有更新，于是又...","head":[["meta",{"property":"og:url","content":"https://liangxinglong-sudo.github.io/knowledge/component/mq/mq-noMore/"}],["meta",{"property":"og:site_name","content":"coder liang"}],["meta",{"property":"og:title","content":"如何处理重复消息"}],["meta",{"property":"og:description","content":"➡️ 如何处理重复消息 重复消息是如何出现的？ 生产者将消息放入Broker等待Broker的响应时，由于网络原因生产者没有收到，然后生产者又重发了一次，此时消息就重复了。 假设消费者拿到消息消费，业务逻辑走完了，事物提交了，此时要更新Consumer offest ，然后消费者挂了，另一个消费者顶上，此时Consumer offest没有更新，于是又..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"tools"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何处理重复消息\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":3.39,"words":1016},"git":{},"autoDesc":true,"filePathRelative":"notes/knowledge/5.component/1.mq/3.mq-noMore.md"}');export{s as comp,c as data};
