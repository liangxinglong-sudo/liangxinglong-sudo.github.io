import{_ as e,c as l,a,d as i,e as t,b as h,w as p,r as k,o as r}from"./app-CpspcPOW.js";const d="/assets/redis1-DjjkpTvm.png",g="/assets/redis2-CiufrEMA.png",o="/assets/redis3-BCxRuaQ3.png",c="/assets/transactional1-DkAHsGjp.png",y="/assets/integer1-Bidy1QwK.png",A={};function v(B,s){const n=k("Annotation");return r(),l("div",null,[s[2]||(s[2]=a('<ol><li><h3 id="为什么要三次握手" tabindex="-1"><a class="header-anchor" href="#为什么要三次握手"><span>为什么要三次握手？</span></a></h3></li></ol><p>简单来说就是为了双方都确认自己的接受和发送都是正常的。</p><ol start="2"><li><h3 id="为什么要四次挥手" tabindex="-1"><a class="header-anchor" href="#为什么要四次挥手"><span>为什么要四次挥手？</span></a></h3></li></ol><p>简单来说任何一方都可以在数据传输结束后发出释放链接的通知，需要对方确认后进入半关闭状态。当另一方也没有数据发送，也发出了释放链接的通知时，且对方确认后才真正关闭了TCP链接。</p><p>举个例子来说就是，A和B打电话，通过即将结束，A说：“我没什么要说的了“，B说：“我知道了”，然后B还没说完，巴拉巴拉说了半天，B又说：“好了，我说完了”，A说：“知道了”，最后挂断了电话。</p><ol start="3"><li><h3 id="cookie的作用-和session的区别" tabindex="-1"><a class="header-anchor" href="#cookie的作用-和session的区别"><span>cookie的作用？和session的区别？</span></a></h3></li></ol><p>cookie一般用来保存用户信息，比如：</p><ul><li>我们在cookie中保存登录过的用户信息，下次访问的时候页面可以自动帮你登录的一些信息填写。</li><li>下次访问网站自动登录的功能一般都是存放了一个Token在cookie中。</li><li>登录后访问网站上的其他页面不需要获取登录</li></ul><p>cookie数据保存在客户端，session数据保存在服务端，相对来说session更安全。</p><ol start="4"><li><h3 id="mysql索引" tabindex="-1"><a class="header-anchor" href="#mysql索引"><span>MySQL索引</span></a></h3></li></ol><p>MySQL索引使用的数据结构主要是BTree索引和哈希索引。对于哈希索引来说，底层的数据结构是哈希表，因此在绝大多数需求为单条记录查询时，可以使用哈希索引，查询性能最快；其余大部分场景，建议使用BTree索引。</p><p>对于两种不同的存储引擎BTree的实现方式是不同的：</p><ul><li><p><strong>MyISAM</strong>：B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果Key存在，则取出data域的值，然后以data域的值为地址读取相应的数据记录。这种方式称为：<strong>非聚簇索引</strong></p></li><li><p><strong>InnoDB</strong>：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件时分离的，其数据文件本身就是按B+Tree组织的索引结构，索引的Key时数据表的主键，因此InnoDB表数据文件本身就是主索引。这种方式称为：<strong>聚簇索引</strong>。</p><p>在根据主索引搜索时，直接找到Key所在的节点即可取出数据；根据辅助索引查找时，需要取出主键的值，再走一遍主索引。所以在设计表时，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样造成主索引频繁分裂。</p></li></ul><ol start="5"><li><h3 id="mysql-锁机制与innodb锁算法" tabindex="-1"><a class="header-anchor" href="#mysql-锁机制与innodb锁算法"><span>MySql 锁机制与InnoDB锁算法</span></a></h3></li></ol><p>MyISAM使用表级锁，InnoDB使用行级锁和表级锁，默认行级锁。</p><p><strong>表级锁</strong>：MySQL中锁定粒度最大的一种锁。对当前整个表进行加锁，实现简单，资源消耗少，加锁快，不会发生死锁。锁定粒度最大，触发锁冲突的概率最高，并发度最低。</p><p><strong>行级锁</strong>：MySQL中锁定粒度最小的一种锁，只针对当前操作的行进行加锁。锁定粒度最小，并发度高，但是加锁开销大，加锁慢，大大减少数据库操作的冲突，可能出现死锁。</p><ol start="6"><li><h3 id="redis是如何判断数据过期的呢-过期删除策略了解过吗" tabindex="-1"><a class="header-anchor" href="#redis是如何判断数据过期的呢-过期删除策略了解过吗"><span>Redis是如何判断数据过期的呢？过期删除策略了解过吗？</span></a></h3></li></ol><p>Redis通过一个叫做过期字段来保存数据过期的时间。过期字段的键指向Redis数据库中的某个key，过期字典的值是long类型的整数，这个整数指向数据库键的过期时间。</p><p>Redis过期删除策略有两种：<strong>惰性删除和过期删除</strong></p><p><strong>惰性删除</strong>：只会在再次取出key时才进行过期检查，但是这样会造成太多key没有删除。</p><p><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</p><p>而Redis采用 <strong>定期删除+惰性/懒汉式删除</strong> ，但是这样仍然会产生很多过期Key，长时间如此导致Out Of Memory，Redis是如何解决的呢？答案就是：<strong>内存淘汰机制</strong>。</p><ol start="7"><li><h3 id="redis内存淘汰机制" tabindex="-1"><a class="header-anchor" href="#redis内存淘汰机制"><span><strong>Redis内存淘汰机制</strong></span></a></h3></li></ol><p><img src="'+d+'" alt="内存淘汰" width="1133" height="1009"></p><p><strong>RANDOM</strong>：随机</p><p><strong>TTL</strong>：从设置了过期时间的 Keys 中获取最早过期的一批 Keys</p><p><strong>LRU</strong>：所有的 Keys 都根据<mark>最后被访问的时间</mark>来进行排序的，所以在淘汰时只需要按照所有 Keys 的最后被访问时间，由小到大来进行即可</p><p><img src="'+g+'" alt="LRU" width="795" height="192"></p><p><strong>LFU</strong>：根据数据的<mark>历史访问频率</mark>来淘汰数据，其核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”</p><p>LFU算法反映了一个key的热度情况，不会因LRU算法的偶尔一次被访问被误认为是热点数据</p><p><img src="'+o+'" alt="LFU" width="775" height="189"></p><ol start="8"><li><h3 id="关于spring事务的传播机制" tabindex="-1"><a class="header-anchor" href="#关于spring事务的传播机制"><span>关于Spring事务的传播机制</span></a></h3></li></ol><p>事务管理是应用系统开发中必不可少的一部分。Spring 为事务管理提供了丰富的功能支持。Spring 事务管理分为编程式和声明式两种。编程式事务指的是通过编码方式实现事务；声明式事务基于 AOP，将具体的逻辑与事务处理解耦。生命式事务管理使业务代码逻辑不受污染，因此实际使用中声明式事务用的比较多。<strong>所以说， spring 是使用 aop 来代理事务控制 ，是针对于接口或类的，所以在同一个 service 类中两个方法的调用，传播机制是不生效的。</strong></p><p>声明式事务有两种方式，一种是在配置文件（XML）中做相关的事务规则声明，另一种是基于 <code>@Transactional</code> 注解的方式。以下介绍基于 <code>@Transactional</code> 注解的事务管理。</p><ul><li>默认配置下（rollbackFor 属性不指定时） Spring 只会回滚运行时、未检查异常（继承自 RuntimeException 的异常）或者 Error。</li><li><code>@Transactional</code> 注解只能应用到 public 方法才有效。</li></ul><p>事务的传播行为，使用<code>propagation</code>属性，默认值为 Propagation.REQUIRED。可选的值有：</p><ul><li><strong>PROPAGATION.REQUIRED</strong>：如果当前没有事务，则创建一个新事务。如果当前存在事务，就加入该事务合并成一个事务。该设置是最常用的设置。</li><li><strong>PROPAGATION.SUPPORTS</strong>：支持当前事务，如果当前存在事务，就加入该事务。如果当前不存在事务，就以非事务执行。</li><li><strong>PROPAGATION.MANDATORY</strong>：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li><strong>PROPAGATION.REQUIRE_NEW</strong>：创建新事务，无论当前存不存在事务，都创建新事务。这个方法会独立提交事务，不受调用者事务影响，父级异常也是正常提交。</li><li><strong>PROPAGATION.NOT_SUPPORTED</strong>：以非事务方式执行操作，如果当前事务存在，就把当前事务挂起。</li><li><strong>PROPAGATION.NEVER</strong>：以非事务方式执行，如果当前存在事务，则抛出异常。即父级方法必须无事务。</li><li><strong>PROPAGATION.NESTED</strong>：如果当前存在事务，则在嵌套事务内执行（它将会成为父级事务的一个子事务，方法结束后并没有提交，只有等父事务结束才提交）。如果当前没有事务，则按 REQUIRED 属性执行。如果它异常，父级可以捕获它的异常而不进行回滚，正常提交。但是如果父级异常，它必然回滚，这是和<code>PROPAGATION.REQUIRE_NEW</code>不同的地方。</li></ul><p><img src="'+c+`" alt="LFU" width="1247" height="355"></p><ol start="9"><li><h3 id="oracle-jdk-vs-open-jdk-的区别" tabindex="-1"><a class="header-anchor" href="#oracle-jdk-vs-open-jdk-的区别"><span>Oracle JDK vs Open JDK 的区别？</span></a></h3></li></ol><p>Oracle JDK 是JDK被Oracle收购后二次开发的开源的工具包，Open JDK大概3个月一更新，Oracle JDK大概6个月一更新，所以Oracle JDK上要上的可能会现在Open JDK上试试水，所以Oracle JDK更稳定。</p><ol start="10"><li><h3 id="包装类型的缓存机制了解过吗" tabindex="-1"><a class="header-anchor" href="#包装类型的缓存机制了解过吗"><span>包装类型的缓存机制了解过吗？</span></a></h3></li></ol><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Integer</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> i1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 40</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Integer</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> i2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">40</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i1</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">==</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//false</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//为什么呢？下面是源码</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Integer </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">valueOf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  if</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> IntegerCache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">low</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &amp;&amp;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&lt;=</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> IntegerCache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">high</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> IntegerCache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">cache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">+</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">-</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">IntegerCache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">low</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)];</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">i</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// &lt;=注意这里</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> IntegerCache</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> low</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> -</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">128</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> high</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  static</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">    // high value may be configured by property</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">    int</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> h</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 127</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>阿里开发手册这么说：</p><p><img src="`+y+`" alt="java开发手册" width="1291" height="267"></p><ol start="11"><li><h3 id="深拷贝和浅拷贝区别了解吗-什么是引用拷贝" tabindex="-1"><a class="header-anchor" href="#深拷贝和浅拷贝区别了解吗-什么是引用拷贝"><span>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</span></a></h3></li></ol><p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p><p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p><p><strong>引用拷贝</strong>：两个不同的引用指向同一个对象。</p><ol start="12"><li><h3 id="string为什么是不可变的" tabindex="-1"><a class="header-anchor" href="#string为什么是不可变的"><span>String为什么是不可变的？</span></a></h3></li></ol><h3 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> String</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> implements</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> java.io.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">Serializable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Comparable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> CharSequence</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  private</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> char</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[];</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">	//...</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们知道被 <code>final</code> 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，<code>final</code> 关键字修饰的数组保存字符串并不是 <code>String</code> 不可变的根本原因，因为这个数组保存的字符串是可变的（<code>final</code> 修饰引用类型变量的情况）。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">={</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> another</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">={</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">4</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">5</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">6</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">=</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">another</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //编译器报错，final不可变</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上述的方式直接改变引用是不允许的，但是我操作数据内部却是可以的</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">final</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> int</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">={</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">};</span></span>
<span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">]=</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">100</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">  //这时候数组里已经是{1,2,100}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>所以String是不可变，关键是因为SUN公司的工程师，在后面所有String的方法里很小心的没有去动Array里的元素，没有暴露内部成员字段。private final char value[]这一句里，<strong>private的私有访问权限的作用都比final大</strong>。而且设计师还很小心地把整个String设成final禁止继承，避免被其他人继承后破坏。所以String是不可变的关键都在底层的实现，而不是一个final。</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">abstract</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> AbstractStringBuilder</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> implements</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Appendable</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> CharSequence</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  byte</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> value</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>Java 9 为何要将 <code>String</code> 的底层实现由 <code>char[]</code> 改成了 <code>byte[]</code> ?</strong></p><p>新版的 String 其实支持两个编码方案： Latin-1 和 UTF-16。如果字符串中包含的汉字没有超过 Latin-1 可表示范围内的字符，那就会使用 Latin-1 作为编码方案。Latin-1 编码方案下，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><p>JDK 官方就说了绝大部分字符串对象只包含 Latin-1 可表示的字符。</p><ol start="13"><li><h3 id="范型有没有用过-怎么用的" tabindex="-1"><a class="header-anchor" href="#范型有没有用过-怎么用的"><span>范型有没有用过？怎么用的？</span></a></h3></li></ol><p>泛型一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong>。</p><p><strong>1.泛型类</strong>：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span>
<span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">//在实例化泛型类时，必须指定T的具体类型</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Generic</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;{</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  private</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  public</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Generic</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">T </span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">)</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#A65E2B;--shiki-dark:#C99076;">    this</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">getKey</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(){</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> key</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如何实例化泛型类：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;">Generic</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> genericInteger</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> new</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> Generic</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;(</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;">123456</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>2.泛型接口</strong> ：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> interface</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> Generator</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">method</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>实现泛型接口，不指定类型：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">class</span><span style="--shiki-light:#2E8F82;--shiki-dark:#5DA994;"> GeneratorImpl</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> implements</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> Generator</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&lt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">T</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">&gt;{</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  @</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Override</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">  public</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> T </span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">method</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">()</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">    return</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> null</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">;</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>3.泛型方法</strong> ：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">public</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> static</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> &lt;</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> E </span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">&gt;</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> void</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;"> printArray</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;"> E</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> inputArray </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">){</span></span>
<span class="line"><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;">  for</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> (</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> E</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> element</span><span style="--shiki-light:#1E754F;--shiki-dark:#4D9375;"> :</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> inputArray </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">){</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">    System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">printf</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">%s </span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> element </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">  }</span></span>
<span class="line"><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">  System</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;">out</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">.</span><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">println</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">();</span></span>
<span class="line"><span style="--shiki-light:#999999;--shiki-dark:#666666;">}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>使用：</p><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" style="--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212;"><pre class="shiki shiki-themes vitesse-light vitesse-dark vp-code"><code><span class="line"><span style="--shiki-light:#A0ADA0;--shiki-dark:#758575DD;">// 创建不同类型数组： Integer, Double 和 Character</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">Integer</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> intArray</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 1</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 2</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#2F798A;--shiki-dark:#4C9A91;"> 3</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> };</span></span>
<span class="line"><span style="--shiki-light:#AB5959;--shiki-dark:#CB7676;">String</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">[]</span><span style="--shiki-light:#B07D48;--shiki-dark:#BD976A;"> stringArray</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> =</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> {</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">Hello</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">,</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;"> &quot;</span><span style="--shiki-light:#B56959;--shiki-dark:#C98A7D;">World</span><span style="--shiki-light:#B5695977;--shiki-dark:#C98A7D77;">&quot;</span><span style="--shiki-light:#999999;--shiki-dark:#666666;"> };</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">printArray</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> intArray  </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span>
<span class="line"><span style="--shiki-light:#59873A;--shiki-dark:#80A665;">printArray</span><span style="--shiki-light:#999999;--shiki-dark:#666666;">(</span><span style="--shiki-light:#393A34;--shiki-dark:#DBD7CAEE;"> stringArray  </span><span style="--shiki-light:#999999;--shiki-dark:#666666;">);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>通常项目中使用范型：</strong></p><p>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型。</p><ol start="14"><li><h3 id="spring框架中都用到了哪些设计模式" tabindex="-1"><a class="header-anchor" href="#spring框架中都用到了哪些设计模式"><span><strong>Spring框架中都用到了哪些设计模式？</strong></span></a></h3></li></ol><ul><li><p>工厂模式：BeanFactory就是简单工厂模式的体现，用来创建对象的实例；</p></li><li><p>单例模式：Bean默认为单例模式。</p></li><li><p>代理模式：Spring的AOP功能用到了JDK的动态代理和CGLIB字节码生成技术；</p></li><li><p>模板方法：用来解决代码重复的问题。比如. RestTemplate, JmsTemplate, JpaTemplate。</p></li><li><p>观察者模式：定义对象键一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知被制动更新，如Spring中listener的实现–ApplicationListener。</p></li></ul><ol start="15"><li><h3 id="事务的隔离级别" tabindex="-1"><a class="header-anchor" href="#事务的隔离级别"><span>事务的隔离级别</span></a></h3></li></ol><p>事务的隔离级别有四种：读未提交、读已提交、可重复读和可串行化。下表展示隔离级别解决的事务问题</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>读已提交</td><td>✅</td><td>❌</td><td>❌</td></tr><tr><td>可重复度</td><td>✅</td><td>✅</td><td>❌</td></tr><tr><td>可串行化</td><td>✅</td><td>✅</td><td>✅</td></tr></tbody></table><p><strong>读未提交</strong></p><p>MySQL 事务隔离其实是依靠锁来实现的，加锁自然会带来性能的损失。而读未提交隔离级别是不加锁的，所以它的性能是最好的，没有加锁、解锁带来的性能开销。但有利就有弊，这基本上就相当于裸奔啊，所以它连脏读的问题都没办法解决。</p><p>举例：别人读到了你没还提交的数据修改结果，别人拿着结果走了，然后你回滚了。</p><p>缺陷：读到了别人没提交的数据</p><p>解决问题：没解决任何问题</p><p><strong>读已提交</strong></p><p>既然读未提交没办法解决脏数据问题，那么就有了读提交。读提交就是一个事务只能读到其他事务已经提交过的数据，也就是其他事务调用 commit 命令之后的数据。那脏数据问题迎刃而解了。读已提交只允许别人在提交后才能读这条数据。</p><p>举例：你要买电脑，可这时你媳妇正在购物，当你要提交订单时钱还够，输完密码说你余额不足</p><p>缺陷：你第一次查和第二次查结果不一样，<u>别人写操作中，你可以进行读操作</u>。</p><p>解决问题：别人提交前的数据你读不到了，解决了脏读</p><p><strong>可重复读</strong></p><p>可重复读是指，就是在开始读取数据（事务开启）时，不再允许修改操作。</p><p>举例：你花了2千元，然后你媳妇去查看你今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，你又花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当你媳妇打印一下你的消费清单，发现花了1.2万元，似乎出现了幻觉，这就是幻读。</p><p>缺陷：重复读可以解决不可重复读问题。写到这里，应该明白的一点就是，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。</p><p>解决问题：你在操作该条数据时别人无法操作，解决了不可重复读</p><p><strong>可串行化</strong> <code>Serializable</code></p><p>Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p><p><strong>为什么MySQL的默认隔离离别是RR?</strong></p><p>binlog的格式也有三种：statement，row，mixed。设置为statement格式，binlog记录的是SQL的原文。又因为MySQL在主从复制的过程是通过binlog进行数据同步，如果设置为读已提交（RC）隔离级别，当出现事务乱序的时候，就会导致备库在 SQL 回放之后，结果和主库内容不一致。</p><ol start="16"><li><h3 id="什么是mysql的mvcc机制" tabindex="-1"><a class="header-anchor" href="#什么是mysql的mvcc机制"><span>什么是Mysql的MVCC机制</span></a></h3></li></ol><p><strong>什么是MVCC</strong></p><p>MVCC全称是多版本并发控制 (Multi-Version Concurrency Control)，只有在InnoDB引擎下存在。MVCC机制的作用其实就是避免同一个数据在不同事务之间的竞争，提高系统的并发性能。</p><p><strong>它的特点如下：</strong></p><ul><li><p>允许多个版本同时存在，并发执行。</p></li><li><p>不依赖锁机制，性能高。</p></li><li><p>只在读已提交和可重复读的事务隔离级别下工作。</p></li></ul><p><strong>MVCC解决什么问题</strong></p><p>在早期的数据库中，只有读读之间的操作才可以并发执行，读写，写读，写写操作都要阻塞，这样就会导致MySQL的并发性能极差。</p><p>采用了MVCC机制后，只有写写之间相互阻塞，其他三种操作都可以并行，这样就可以提高了MySQL的并发性能。</p><p><strong>原理是什么</strong></p><p>我们都知道，MySQL事务隔离级别有四种，分别是读未提交(Read Uncommitted，简称RU)、读已提交(Read Committed，简称RC)、可重复读(Repeatable Read，简称RR)、串行化(Serializable)，只有RC和RR才跟MVCC机制相关，RU和Serializable都不会使用到MVCC机制。因为在读未提交(RU)级别下是直接返回记录上的最新值，Serializable级别下则会对所有读取的行都加锁。</p><p>实现 MVCC 要依赖：<code>隐藏字段</code>、<code>Read View</code>、<code>Undo log</code></p><p><strong>接下来要介绍几个mvcc的概念</strong></p>`,114)),i("p",null,[i("strong",null,[s[1]||(s[1]=t("ReadView ")),h(n,{label:"ReadView",total:1},{"item-0":p(()=>s[0]||(s[0]=[i("p",null,"读视图",-1)])),_:1})])]),s[3]||(s[3]=a("<p>跟快照、snapshot是一个概念。可以理解为数据库中某一个时刻所有未提交事务的快照。ReadView 有几个重要的参数：</p><p><code>m_ids</code>：表示生成ReadView时，当前系统正在活跃的读写事务的事务Id列表。</p><p><code>min_trx_id</code>：表示生成ReadView时，当前系统中活跃的读写事务的最小事务Id。</p><p><code>max_trx_id</code>：表示生成ReadView时，当前时间戳InnoDB将在下一次分配的事务id。</p><p><code>creator_trx_id</code>：当前事务id。</p><p>所以当创建ReadView时，可以知道这个时间点上未提交事务的所有信息。</p><p><strong>隐藏列</strong></p><p>InnoDB存储引擎中，它的聚簇索引记录中都包含两个必要的隐藏列，分别是：</p><p><code>trx_id</code>：事务Id，每次一个事务对某条聚簇索引记录进行改动时，都会把该事务的事务id赋值给trx_id隐藏列。</p><p><code>roll_pointer</code>：回滚指针，每次对某条聚簇索引记录进行改动时，都会把旧的版本写入到undo log中，然后这个隐藏列就相当于一个指针，可以通过它来找到该记录修改前的信息。</p><p><strong>事务链</strong></p><p>每次对记录进行修改时，都会记录一条 undo log 信息，每一条 undo log 信息都会有一个 roll_pointer 属性(INSERT操作没有这个属性，因为之前没有更早的版本)，可以将这些 undo 日志都连起来，串成一个链表。</p><p>RC和RR隔离级别的实现就是通过版本控制来完成，<strong>核心处理逻辑就是判断所有版本中哪个版本是当前事务可见的处理</strong>。两者最大的区别在于<strong>生成 ReadView 的时机的不同</strong>，RC级别生成 ReadView 的时机是每次查询都会生成新的ReadView，而RR级别是在当前事务第一次查询时生成，并且生成的 ReadView 会一直沿用到事务提交为止，保证可重复读。通过什么判断呢？就是上文讲到的ReadView，ReadView包含了当前系统活跃的读写事务的信息，判断的逻辑如下：</p><ul><li><p>如果被访问版本的 <code>trx_id</code> 属性值小于ReadView的最小事务Id，表示该版本的事务在生成 ReadView 前已经提交，所以该版本可以被当前事务访问。</p></li><li><p>如果被访问版本的 <code>trx_id</code> 属性值大于ReadView的最大事务Id，表示该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。</p></li><li><p>如果被访问版本的 <code>trx_id</code> 属性值在ReadView的最小事务Id和最大事务Id之间，那就需要判断一下 <code>trx_id</code> 属性值是不是包含在 <code>m_ids</code> 列表中，如果包含的话，说明创建 ReadView 时生成该版本的事务还是活跃的，所以该版本不可以访问；如果不包含的话，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</p></li></ul><p>只有 RC 和 RR 的隔离级别才会使用 MVCC 机制，两者最大的区别在于生成 ReadView 的时机的不同，RC级别生成 ReadView 的时机是每次查询都会生成新的 ReadView，而RR级别是在当前事务第一次查询时生成，并且生成的 ReadView 会一直沿用到事务提交为止，保证可重复读。</p>",15))])}const m=e(A,[["render",v]]),D=JSON.parse('{"path":"/notes/storys/view/","title":"找工作的故事","lang":"zh-CN","frontmatter":{"title":"找工作的故事","icon":"healthicons:group-discussion-meetingx3-outline","createTime":"2025/04/10 17:30:06","permalink":"/notes/storys/view/","description":"为什么要三次握手？ 简单来说就是为了双方都确认自己的接受和发送都是正常的。 为什么要四次挥手？ 简单来说任何一方都可以在数据传输结束后发出释放链接的通知，需要对方确认后进入半关闭状态。当另一方也没有数据发送，也发出了释放链接的通知时，且对方确认后才真正关闭了TCP链接。 举个例子来说就是，A和B打电话，通过即将结束，A说：“我没什么要说的了“，B说：“...","head":[["meta",{"property":"og:url","content":"https://liangxinglong-sudo.github.io/notes/storys/view/"}],["meta",{"property":"og:site_name","content":"coder liang"}],["meta",{"property":"og:title","content":"找工作的故事"}],["meta",{"property":"og:description","content":"为什么要三次握手？ 简单来说就是为了双方都确认自己的接受和发送都是正常的。 为什么要四次挥手？ 简单来说任何一方都可以在数据传输结束后发出释放链接的通知，需要对方确认后进入半关闭状态。当另一方也没有数据发送，也发出了释放链接的通知时，且对方确认后才真正关闭了TCP链接。 举个例子来说就是，A和B打电话，通过即将结束，A说：“我没什么要说的了“，B说：“..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"找工作的故事\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":17.93,"words":5379},"git":{},"autoDesc":true,"filePathRelative":"notes/storys/view.md"}');export{m as comp,D as data};
