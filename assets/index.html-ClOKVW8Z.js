import{_ as o,c as e,a as r,o as n}from"./app-0cHkJ8w3.js";const a="/assets/mq-queue-ptbV_ofl.png",s="/assets/mq-dy-BZefs0vS.png",d="/assets/mq1-DBZOlWHr.png",c="/assets/mq2-BBGRMyDw.png",p={};function i(g,t){return n(),e("div",null,t[0]||(t[0]=[r('<div class="hint-container tip"><p class="hint-container-title">维基百科</p><p>在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或者同一进程内的线程通信。它们通过队列来传递消息-控制信息或者内容，群组通信系统提供类似的功能。</p></div><p>简单概括就是：消息队列就是使用队列来通信的组件。</p><h2 id="为什么需要消息队列" tabindex="-1"><a class="header-anchor" href="#为什么需要消息队列"><span>为什么需要消息队列？</span></a></h2><p>从以前的单体架构到现在的微服务架构，成百上千的服务器之间相互调用和依赖。所以我们需要某个东西用来应用解耦服务之间的关系，控制资源合理和时的使用以及缓冲流量高峰等等。 所以消息队列就这么诞生了，常用于：<strong>异步处理</strong>、<strong>服务解耦</strong>、<strong>流量控制</strong>。</p><h3 id="异步处理" tabindex="-1"><a class="header-anchor" href="#异步处理"><span>➡️ 异步处理</span></a></h3><p><strong>请求链路越来越长</strong>。调用链路长了，响应就慢了，对于一些不需要及时响应的服务，扔到消息队列中就可以直接返回结果了。所以消息队列可以减少请求的等待时间，让服务异步处理，提升系统的总体性能。</p><h3 id="服务解耦" tabindex="-1"><a class="header-anchor" href="#服务解耦"><span>➡️ 服务解耦</span></a></h3><p>当业务扩张，下游系统不断增加，为了迎合下游系统原系统需要不断的修改，任何一个系统接口的变更都会影响原服务，所以一本都会使用消息队列来解决系统至今的耦合问题，原系统将相关消息放入消息队列中，下游系统需要就去订阅这个主题。</p><h3 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span>➡️ 流量控制</span></a></h3><ol><li>一些秒杀活动爆发式的流量可能系统会顶不住。</li><li>某个服务请求过来后，后端的处理的流程复杂且长</li></ol><p>上述两种情况分别对应生产者过快和消费者过慢的问题，消息队列都能很好的解决上述问题。</p><div class="hint-container warning"><p class="hint-container-title">注意</p><p>引入消息队列固然有以上的好处，但是多引入一个中间件系统稳定性就下降一层，运维难度就上升一层。</p></div><h2 id="如何选择" tabindex="-1"><a class="header-anchor" href="#如何选择"><span>如何选择？</span></a></h2><table><thead><tr><th><strong>特性</strong></th><th><strong>ActiveMQ</strong></th><th><strong>RabbitMQ</strong></th><th><strong>RocketMQ</strong></th><th><strong>Kafka</strong></th></tr></thead><tbody><tr><td><strong>单机吞吐量</strong></td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td><strong>topic 数量对吞吐量的影响</strong></td><td></td><td></td><td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td><strong>时效性</strong></td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td><strong>可用性</strong></td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td><strong>消息可靠性</strong></td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td><strong>功能支持</strong></td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃。</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高。</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 Apache，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p><h2 id="消息队列两种模型" tabindex="-1"><a class="header-anchor" href="#消息队列两种模型"><span>消息队列两种模型</span></a></h2><p>消息队列有两种模型：<strong>队列模型和发布/订阅模型</strong></p><h3 id="队列模型" tabindex="-1"><a class="header-anchor" href="#队列模型"><span>➡️ 队列模型</span></a></h3><p><img src="'+a+'" alt="队列模型" width="1082" height="337"></p><p>一个队列可以存储多个生产者的消息，一个队列也可以有多个消费者，但是消费者之间是 <strong>竞争关系</strong> ，即一个消息只能被一个消费者消费。</p><h3 id="发布-订阅模型" tabindex="-1"><a class="header-anchor" href="#发布-订阅模型"><span>➡️ 发布/订阅模型</span></a></h3><p><img src="'+s+'" alt="队列模型" width="916" height="443"></p><p>为了解决 <strong>一个消息只能被一个消费者消费的问题</strong>，于是便有了发布/订阅模型，该模型是将消息发往一个 <mark>Topic</mark> 即主题中，订阅了这个主题就能消费这个消息。</p><p>换个说法，<strong>发布/订阅模式</strong> 就等于我们都加入了一个群聊中，我发一条消息，加入了这个群聊的人都可以收到这条消息。<strong>队列模型</strong> 就是一对一聊天，我给你发消息只可以在和你的聊天窗口中，不会出现在其他人窗口去。</p><p>那又有人说，那我一对一聊天将这一条消息发送给很多个人不一样的道理吗？是的。 <mark>通过全队列全量存储相同的消息，即数据冗余可以实现一条消息被多个消费者消费</mark> 。<code>RabbitMQ</code> 就是采用队列模型，通过 <code>Exchange</code> 模块来将消息发送至多个队列，解决一条消息多个消费者消费的问题。</p><div class="hint-container tip"><p class="hint-container-title">总结</p><p><code>RabbitMQ</code>采用队列模型，<code>RocketMQ</code>和<code>Kafka</code>采用发布/订阅模型。</p></div><h2 id="发布-订阅模型有哪些组件" tabindex="-1"><a class="header-anchor" href="#发布-订阅模型有哪些组件"><span>发布/订阅模型有哪些组件</span></a></h2><p><img src="'+d+'" alt="mq三大组成" width="842" height="230"></p><p><strong>一般称消息发送方为<code>Producer</code>，接收消息方为<code>Consumer</code>，消息队列服务端为<code>Broker</code>。</strong></p><p>消息从<code>Producer</code>发往<code>Broker</code>，<code>Broker</code>将消息存到本地，然后<code>Consumer</code>从<code>Broker</code>拉取消息，或者<code>Broker</code>推送消息到<code>Consumer</code>，然后消费。</p><p>为了提高并发度，往往发布/订阅模型还会引入<strong>队列</strong>或者<strong>分区</strong>的概念。消息是发往一个主题(Topic)下的某个队列或者分区中。<code>RocketMQ</code>中叫队列，<code>KafKa</code>中叫分区，本质一样。 例如，某个主题下有5个队列，那么这个主题的并发度为5，同时可以支持5个消费者并行消费该主题中的消息。一般都是采用轮询或者hash算法将消息费发到主题的不同队列中。</p><p><strong>消费者一般都有组的概念 Consumer Group，即消费者都是属于某个消费组，一条消息会发往多个订阅了这个主题的消费组。</strong></p><p><img src="'+c+'" alt="mq-group" width="843" height="580"></p><p>一条消息在Broker中只会有一份，每个消费组有自己的offset即消费点位标识消费到的位置，消费点位前说明已经消费过了。消费点位是队列级别的，每个消费组都会维护订阅的Topic下的每个队列的offset。</p>',38)]))}const l=o(p,[["render",i]]),m=JSON.parse('{"path":"/knowledge/component/mq/mq/","title":"消息队列入门介绍","lang":"zh-CN","frontmatter":{"title":"消息队列入门介绍","icon":"tabler:message","category":["开发工具"],"tag":["tools"],"createTime":"2025/04/10 17:28:06","permalink":"/knowledge/component/mq/mq/","description":"维基百科 在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或者同一进程内的线程通信。它们通过队列来传递消息-控制信息或者内容，群组通信系统提供类似的功能。 简单概括就是：消息队列就是使用队列来通信的组件。 为什么需要消息队列？ 从以前的单体架构到现在的微服务架构，成百上千的服务器之间相互调用和依赖。所以我们需要某个东西用来应用解耦服务之...","head":[["meta",{"property":"og:url","content":"https://liangxinglong-sudo.github.io/knowledge/component/mq/mq/"}],["meta",{"property":"og:site_name","content":"coder liang"}],["meta",{"property":"og:title","content":"消息队列入门介绍"}],["meta",{"property":"og:description","content":"维基百科 在计算机科学领域，消息队列和邮箱都是软件工程组件，通常用于进程间或者同一进程内的线程通信。它们通过队列来传递消息-控制信息或者内容，群组通信系统提供类似的功能。 简单概括就是：消息队列就是使用队列来通信的组件。 为什么需要消息队列？ 从以前的单体架构到现在的微服务架构，成百上千的服务器之间相互调用和依赖。所以我们需要某个东西用来应用解耦服务之..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"tools"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"消息队列入门介绍\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[]}"]]},"headers":[],"readingTime":{"minutes":6.84,"words":2051},"git":{},"autoDesc":true,"filePathRelative":"notes/knowledge/5.component/1.mq/1.mq.md"}');export{l as comp,m as data};
