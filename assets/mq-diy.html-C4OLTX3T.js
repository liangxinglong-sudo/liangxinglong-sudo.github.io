import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as o,d as t,o as a}from"./app-CAOD8xuQ.js";const n={};function p(i,r){return a(),o("div",null,r[0]||(r[0]=[t('<ol><li><p>首先需要明确地提出 <mark>消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心</mark>。</p></li><li><p>简述下消息中间件数据流转过程，无非就是 <mark>生产者生产消息，发送至Broker，Broker可以暂缓消息，然后消费者再从Broker获取消息，用于消费</mark>。</p></li><li><p>而注册中心用于服务的发现包括：<mark>Broker的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心</mark>。</p></li><li><p>然后开始讲述实现要点： <mark>各个模块的通信基于Netty然后自定义协议来实现</mark> ，注册中心可以利用Zookeeper、consul、eureka、nacos等等，<strong>也可以像RockerMQ自己实现简单的namesrv</strong></p></li><li><p>为了考虑扩容和整体的性能，采用分布式思想，就像<strong>kafka一样采取分区理念</strong>， <mark>一个Topic分为多个partition，并且为了保证数据可靠性，采取多副本存储，即Leader和follower</mark> ，根据性能和数据可靠的权衡提供异步和同步的输盘存储</p></li><li><p>还可以利用 <mark>选举算法保证Leader挂了之后follower可以顶上</mark> ，保证消息队列的高可用</p></li><li><p>为了提供消息的可靠性， <mark>利用本地文件系统来存储消息</mark> ，并且采用顺序写的方式来提高性能</p></li><li><p>根据消息队列的特性 <mark>利用内存映射、零拷贝进一步提升性能</mark> ，<strong>还可以利用像kafka这种批处理思想提高整体的吞吐量</strong>。</p></li></ol><div class="hint-container tip"><p class="hint-container-title">衍生问题</p><ol><li>Netty是什么？各注册中心之间的选型对比？</li></ol><p>2.选举算法，Bully 算法、Raft 算法、ZAB 算法等等？</p><p>3.分区，这个分区和 RocketMQ 的队列有什么不同？具体分区要怎么实现？</p><p>4.顺序写，为什么要顺序写啊？内存映射和零拷贝又是什么啊？RocketMQ 和 Kafka 用了哪个吗?</p><p>5.消息的写入如何存储、消息的索引如何生成等等？有没有看过消息中间件的源码？</p></div>',2)]))}const k=e(n,[["render",p]]),c=JSON.parse('{"path":"/component/mq/mq-diy.html","title":"如何写个消息中间件","lang":"zh-CN","frontmatter":{"title":"如何写个消息中间件","icon":"hammer","category":["开发工具"],"tag":["tools"],"description":"首先需要明确地提出 消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心。 简述下消息中间件数据流转过程，无非就是 生产者生产消息，发送至Broker，Broker可以暂缓消息，然后消费者再从Broker获取消息，用于消费。 而注册中心用于服务的发现包括：Broker的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/component/mq/mq-diy.html"}],["meta",{"property":"og:site_name","content":"CODER LIANG"}],["meta",{"property":"og:title","content":"如何写个消息中间件"}],["meta",{"property":"og:description","content":"首先需要明确地提出 消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心。 简述下消息中间件数据流转过程，无非就是 生产者生产消息，发送至Broker，Broker可以暂缓消息，然后消费者再从Broker获取消息，用于消费。 而注册中心用于服务的发现包括：Broker的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"tools"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"如何写个消息中间件\\",\\"image\\":[\\"\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Coder Liang\\",\\"url\\":\\"https://blog.csdn.net/Phone_1070333541?type=blog\\"}]}"]]},"git":{},"readingTime":{"minutes":1.85,"words":555},"filePathRelative":"component/mq/mq-diy.md","excerpt":"<ol>\\n<li>\\n<p>首先需要明确地提出 <mark>消息中间件的几个重要角色，分别是生产者、消费者、Broker、注册中心</mark>。</p>\\n</li>\\n<li>\\n<p>简述下消息中间件数据流转过程，无非就是 <mark>生产者生产消息，发送至Broker，Broker可以暂缓消息，然后消费者再从Broker获取消息，用于消费</mark>。</p>\\n</li>\\n<li>\\n<p>而注册中心用于服务的发现包括：<mark>Broker的发现、生产者的发现、消费者的发现，当然还包括下线，可以说服务的高可用离不开注册中心</mark>。</p>\\n</li>\\n<li>\\n<p>然后开始讲述实现要点： <mark>各个模块的通信基于Netty然后自定义协议来实现</mark> ，注册中心可以利用Zookeeper、consul、eureka、nacos等等，<strong>也可以像RockerMQ自己实现简单的namesrv</strong></p>\\n</li>\\n<li>\\n<p>为了考虑扩容和整体的性能，采用分布式思想，就像<strong>kafka一样采取分区理念</strong>， <mark>一个Topic分为多个partition，并且为了保证数据可靠性，采取多副本存储，即Leader和follower</mark> ，根据性能和数据可靠的权衡提供异步和同步的输盘存储</p>\\n</li>\\n<li>\\n<p>还可以利用 <mark>选举算法保证Leader挂了之后follower可以顶上</mark> ，保证消息队列的高可用</p>\\n</li>\\n<li>\\n<p>为了提供消息的可靠性， <mark>利用本地文件系统来存储消息</mark> ，并且采用顺序写的方式来提高性能</p>\\n</li>\\n<li>\\n<p>根据消息队列的特性 <mark>利用内存映射、零拷贝进一步提升性能</mark> ，<strong>还可以利用像kafka这种批处理思想提高整体的吞吐量</strong>。</p>\\n</li>\\n</ol>","autoDesc":true}');export{k as comp,c as data};
