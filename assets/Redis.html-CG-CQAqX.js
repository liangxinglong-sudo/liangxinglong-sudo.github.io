import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as a,d as e}from"./app-BrrEAuRv.js";const l={},n=e(`<h1 id="redis" tabindex="-1"><a class="header-anchor" href="#redis"><span>Redis</span></a></h1><h2 id="一、介绍" tabindex="-1"><a class="header-anchor" href="#一、介绍"><span>一、介绍</span></a></h2><ol><li><h3 id="关系型数据库-和-非关系型数据库" tabindex="-1"><a class="header-anchor" href="#关系型数据库-和-非关系型数据库"><span>关系型数据库 和 非关系型数据库</span></a></h3><ul><li><h4 id="关系型数据库-mysql-oracle" tabindex="-1"><a class="header-anchor" href="#关系型数据库-mysql-oracle"><span>关系型数据库：MySQL Oracle ..</span></a></h4><p>特点：数据结构严谨（库，表，字段..），插入数据严格符合声明的数据类型。</p><p>ACID：原子性，一致性，独立性，持久性</p></li><li><h4 id="非关系型数据库-redis-hbase" tabindex="-1"><a class="header-anchor" href="#非关系型数据库-redis-hbase"><span>非关系型数据库：Redis Hbase ...</span></a></h4><p>特点：数据结构不严谨、松散，</p><p>CAP：强一致性，可用性，分区容错性</p></li></ul></li><li><h3 id="web-1-0-和-web-2-0" tabindex="-1"><a class="header-anchor" href="#web-1-0-和-web-2-0"><span>WEB 1.0 和 WEB 2.0</span></a></h3><ul><li><h4 id="web-1-0" tabindex="-1"><a class="header-anchor" href="#web-1-0"><span>WEB 1.0</span></a></h4><p>用户大多情况只是浏览数据。</p></li><li><h4 id="web-2-0" tabindex="-1"><a class="header-anchor" href="#web-2-0"><span>WEB 2.0</span></a></h4><p>用户开始产生数据。这就产生了问题。</p><ul><li><p>高并发：同一时刻多个用户往数据库插入数据。</p></li><li><p>海量数据：存储大量数据。</p></li><li><p>高扩展性与可用性：服务器切换方式 与 停机时间 。</p></li></ul></li></ul></li><li><h3 id="nosql-not-only-sql" tabindex="-1"><a class="header-anchor" href="#nosql-not-only-sql"><span>NoSQL ：not only sql</span></a></h3></li><li><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h3><ul><li><h4 id="多数据库。-默认16个-0-15" tabindex="-1"><a class="header-anchor" href="#多数据库。-默认16个-0-15"><span>多数据库。（默认16个 [ 0~15 ])</span></a></h4><p>select 库索引 可以选择数据库存数据。</p><p>dbsize 查看当前数据库长度</p><p>flush 删除数据库内容</p></li><li><h4 id="消息的订阅与发布" tabindex="-1"><a class="header-anchor" href="#消息的订阅与发布"><span>消息的订阅与发布</span></a></h4><p>subscribe 订阅关键字 （完全匹配）</p><p>public 发布 键 值</p><p>psubscribe 订阅关键字（关键字匹配）</p></li></ul></li></ol><h2 id="二、数据类型" tabindex="-1"><a class="header-anchor" href="#二、数据类型"><span>二、数据类型</span></a></h2><ol><li><h3 id="键约束-长度不能超过1024字节-见名知意" tabindex="-1"><a class="header-anchor" href="#键约束-长度不能超过1024字节-见名知意"><span>键约束：长度不能超过1024字节，见名知意</span></a></h3></li><li><h3 id="五种数据类型" tabindex="-1"><a class="header-anchor" href="#五种数据类型"><span>五种数据类型</span></a></h3><table><thead><tr><th style="text-align:left;">redis类型</th><th style="text-align:left;">对应java类型</th></tr></thead><tbody><tr><td style="text-align:left;">String</td><td style="text-align:left;">String （内存缓存）</td></tr><tr><td style="text-align:left;">Has</td><td style="text-align:left;">HashMap （复杂的内存缓存）</td></tr><tr><td style="text-align:left;">List</td><td style="text-align:left;">LinkedList （避免数据推送丢失 rpop lpush）</td></tr><tr><td style="text-align:left;">Set</td><td style="text-align:left;">HashSet （查看访问用户的数量[去重]）</td></tr><tr><td style="text-align:left;">SortedSet</td><td style="text-align:left;">TreeSet （实时排名</td></tr></tbody></table></li></ol><h2 id="三、连接池" tabindex="-1"><a class="header-anchor" href="#三、连接池"><span>三、连接池</span></a></h2><ol><li><h3 id="用法" tabindex="-1"><a class="header-anchor" href="#用法"><span>用法</span></a></h3><div class="language-java line-numbers-mode" data-highlighter="shiki" data-ext="java" data-title="java" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//1. 设置初始化参数。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">JedisPoolConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> pc </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> JedisPoolConfig</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">()</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">pc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setMaxTotal</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">100</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//最大链接数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">pc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setMaxIdle</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//最大空闲连接数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">pc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setMinIdle</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//最小空闲连接数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">pc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">setMaxWaitMillis</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//最大等待时间</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//2. 根据初始化参数创建连接池</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">JedisPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> pool </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> JedisPool</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">(pc</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">&quot;ip&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">，</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">6379</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">)</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//3. 从连接池获取链接。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">Jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> jedis </span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;"> pool</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">getResource</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//4. 使用链接。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">jdeis</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(key);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//5. 存回连接池。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">jedis</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">close</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">();</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  //省略了fiinally包起来</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><h3 id="池-思想" tabindex="-1"><a class="header-anchor" href="#池-思想"><span>&#39;池&#39;思想</span></a></h3><ul><li><h4 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理 ：</span></a></h4><p>创建容器，预先存储若干资源。</p><p>使用资源时从容器中取出现成的。</p><p>使用完毕，放回容器。</p></li><li><h4 id="特点-效率高-节约资源。" tabindex="-1"><a class="header-anchor" href="#特点-效率高-节约资源。"><span>特点：效率高，节约资源。</span></a></h4></li></ul></li></ol><h2 id="四、持久化" tabindex="-1"><a class="header-anchor" href="#四、持久化"><span>四、持久化</span></a></h2><p>redis 的数据都是在内存中的，有安全隐患(关系型数据库备份)。redis 自身实现了持久化：</p><ol><li><h3 id="rdb-模式官方推荐-默认开启-repeat-database" tabindex="-1"><a class="header-anchor" href="#rdb-模式官方推荐-默认开启-repeat-database"><span>RDB (模式官方推荐，默认开启 [Repeat DataBase])</span></a></h3><p>隔一段时间将 redis 数据 序列化到磁盘。</p><ul><li><h4 id="实现策略" tabindex="-1"><a class="header-anchor" href="#实现策略"><span>实现策略</span></a></h4><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    900</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    1</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  #15分钟，有1个key 改变，就序列化。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    300</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    10</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   #5分钟，有10个key 改变，就序列化。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">save</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">    60</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">      10000</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  #在1分钟内 有1w个key 改变，就序列化。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><h4 id="存储位置-dbfilename-dump-rdb" tabindex="-1"><a class="header-anchor" href="#存储位置-dbfilename-dump-rdb"><span>存储位置：dbfilename dump.rdb</span></a></h4></li></ul></li><li><h3 id="aof-模式。-append-only-file" tabindex="-1"><a class="header-anchor" href="#aof-模式。-append-only-file"><span>AOF 模式。(Append Only File)</span></a></h3><p>当数据有变化时，就序列化到磁盘</p><ul><li><h4 id="实现策略-1" tabindex="-1"><a class="header-anchor" href="#实现策略-1"><span>实现策略</span></a></h4><div class="language-shell line-numbers-mode" data-highlighter="shiki" data-ext="shell" data-title="shell" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">#redis.conf 配置文件里</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">appendonly</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;"> no</span><span style="--shiki-light:#032F62;--shiki-dark:#98C379;">    yes</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">   #启用</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">#(用哪个就把注释干掉)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"># appendfsync    always</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"># appendfsync    everysec</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;"># appendfsync    no</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><h4 id="存储位置-appendonly-aof" tabindex="-1"><a class="header-anchor" href="#存储位置-appendonly-aof"><span>存储位置：appendonly.aof</span></a></h4></li></ul></li></ol><h2 id="五、redis-单线程模型详解-摘自guide哥" tabindex="-1"><a class="header-anchor" href="#五、redis-单线程模型详解-摘自guide哥"><span>五、Redis 单线程模型详解 (摘自<a href="https://snailclimb.gitee.io/javaguide/#/docs/database/Redis/redis-all?id=_7-redis-%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E8%AF%A6%E8%A7%A3" target="_blank" rel="noopener noreferrer">Guide哥</a>)</span></a></h2><p><strong>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p><p>Redis 通过<strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。</p><p>时间事件不需要多花时间了解，我们接触最多的还是 <strong>文件事件</strong>（客户端进行读取写入等操作，涉及一系列网络通信）。</p><p>《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。</p><p>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</p><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p>可以看出，文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>多个 socket（客户端连接）</li><li>IO 多路复用程序（支持多个客户端连接的关键）</li><li>文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><figure><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gogaxmz18bj30kb0f0jsr.jpg" alt="事件处理器" tabindex="0" loading="lazy"><figcaption>事件处理器</figcaption></figure><h2 id="六、redis集群" tabindex="-1"><a class="header-anchor" href="#六、redis集群"><span>六、redis集群</span></a></h2><p>redis最开始使用主从模式做集群，若master宕机需要手动配置slave转为master；后来为了高可用提出来<strong>哨兵</strong>模式，该模式下有一个哨兵监视master和slave，若master宕机可自动将slave转为master，但它也有一个问题，就是不能动态扩充，所有有了现在的cluster集群模式</p><ol><li><h3 id="结构特点" tabindex="-1"><a class="header-anchor" href="#结构特点"><span>结构特点</span></a></h3><ul><li><p>redis节点彼此互联(ping-pong机制)，内部使用二进制协议</p></li><li><p>fail通过投票来判断</p></li><li><p>客户端随意连接其中一个redis即可</p></li><li><p>节点=&gt;插槽=&gt;数据</p></li></ul></li><li><h3 id="插槽" tabindex="-1"><a class="header-anchor" href="#插槽"><span>插槽</span></a></h3><p><strong>搭建集群的时候会把0～16383个插槽分配给节点(服务器)</strong>，就类似于标识，0～5000 都是第一个节点，5000～10000就是第二个节点，剩余的就是第三个节点</p></li><li><h3 id="在redis集群执行-set-a-a-往里放值-get-a-取数同理" tabindex="-1"><a class="header-anchor" href="#在redis集群执行-set-a-a-往里放值-get-a-取数同理"><span>在redis集群执行 “set a a” 往里放值 （get a 取数同理）</span></a></h3><ul><li><p>连接任意一个节点 例如node3</p></li><li><p>对key，就是命令的a，进行crc16算法的计算，得到一个数字，也就是进行 16384 的求余，结果的范围就会是在0～16383之中，例如某个数字对3取余：</p><p>1&amp;3=1，2%3=2，3%3=0，4%3=1....，结果就是在0～2之间。</p></li><li><p>假如上个步骤得到的数字为3000，就在集群中查找有3000这个插槽slot的节点，此时找到node1</p></li><li><p>连接跳转到node1，在node1上执行 &quot;set a a &quot;</p></li></ul></li><li><h3 id="redis-cluster主从模式" tabindex="-1"><a class="header-anchor" href="#redis-cluster主从模式"><span>Redis Cluster主从模式</span></a></h3><p>redis cluster 为了保证数据的高可用性，加入了主从模式，一个主节点对应一个或多个从节点，主节点提供数据存取，从节点则是从主节点拉取数据备份，当这个主节点挂掉后，就会有这个从节点选取一个来充当主节点，从而保证集群不会挂掉</p><p>上面那个例子里, 集群有ABC三个主节点, 如果这3个节点都没有加入从节点，如果B挂掉了，我们就无法访问整个集群了，A和C的slot也无法访问</p><p>所以我们在集群建立的时候，一定要为每个主节点都添加了从节点, 比如像这样, 集群包含主节点A、B、C, 以及从节点A1、B1、C1, 那么即使B挂掉系统也可以继续正确工作</p><p>B1节点替代了B节点，所以Redis集群将会选择B1节点作为新的主节点，集群将会继续正确地提供服务。 当B重新开启后，它就会变成B1的从节点</p><p>不过需要注意，如果节点B和B1同时挂了，Redis集群就无法继续正确地提供服务了</p></li><li><h3 id="集群是如何判断是否有某个节点挂掉" tabindex="-1"><a class="header-anchor" href="#集群是如何判断是否有某个节点挂掉"><span>集群是如何判断是否有某个节点挂掉</span></a></h3><p>首先要说的是，每一个节点都存有这个集群所有主节点以及从节点的信息。它们之间通过互相的ping-pong判断是否节点可以连接上。如果有一半以上的节点去ping一个节点的时候没有回应，集群就认为这个节点宕机了，然后去连接它的备用节点</p></li><li><h3 id="集群进入fail状态的必要条件" tabindex="-1"><a class="header-anchor" href="#集群进入fail状态的必要条件"><span>集群进入fail状态的必要条件</span></a></h3><ul><li>某个主节点和所有从节点全部挂掉，我们集群就进入faill状态</li><li>如果集群超过半数以上master挂掉，无论是否有slave，集群进入fail状态</li><li>如果集群任意master挂掉,且当前master没有slave.集群进入fail状态</li></ul></li></ol><h2 id="七、redis淘汰策略" tabindex="-1"><a class="header-anchor" href="#七、redis淘汰策略"><span>七、Redis淘汰策略</span></a></h2><p>详情见面试题第6点</p><h2 id="八、缓存穿透和缓存击穿" tabindex="-1"><a class="header-anchor" href="#八、缓存穿透和缓存击穿"><span>八、缓存穿透和缓存击穿</span></a></h2><p>简短来说就是：”穿透“ 打透了什么都没有，“击穿” 破甲之后拿到了。</p><p><strong>缓存穿透</strong>：大量请求去请求一个本身就不存在的数据，比如数据库中user表userId是“1，2，3，4，5...”，这个时候有大量的请求来取id=0或者id=-1的数据，发现缓存中没有就去数据库中，然后发现数据库中也没有。</p><p><strong>缓存击穿</strong>：某个key可能再某个瞬间到期了，导致所有的请求都去数据库中去取值。</p><p><strong>缓存雪崩</strong>：大量key在某个时间失效，造成大量请求都去请求数据库，增加数据库的压力</p><h2 id="九、先更新缓存还是先更新数据库" tabindex="-1"><a class="header-anchor" href="#九、先更新缓存还是先更新数据库"><span>九、先更新缓存还是先更新数据库？</span></a></h2><blockquote><p>没有最完美的方案，只有最适合的方案。每个方案都有自己的缺陷也有自己的优点</p></blockquote><h3 id="常见的策略有" tabindex="-1"><a class="header-anchor" href="#常见的策略有"><span>常见的策略有：</span></a></h3><ul><li>cache aside （旁路缓存）</li><li>Read/Write through</li><li>Write behind caching</li></ul><h3 id="cache-aside" tabindex="-1"><a class="header-anchor" href="#cache-aside"><span><code>cache aside</code></span></a></h3><figure><img src="https://tva1.sinaimg.cn/large/008vxvgGly1h7rrry2hmtj30710gi0sy.jpg" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>​</p>`,39),t=[n];function h(p,r){return a(),s("div",null,t)}const c=i(l,[["render",h],["__file","Redis.html.vue"]]),o=JSON.parse('{"path":"/dbs/Redis.html","title":"Redis","lang":"zh-CN","frontmatter":{"title":"Redis","icon":"object-group","category":["数据库"],"tag":["SQL"],"description":"Redis 一、介绍 关系型数据库 和 非关系型数据库 关系型数据库：MySQL Oracle .. 特点：数据结构严谨（库，表，字段..），插入数据严格符合声明的数据类型。 ACID：原子性，一致性，独立性，持久性 非关系型数据库：Redis Hbase ... 特点：数据结构不严谨、松散， CAP：强一致性，可用性，分区容错性 WEB 1.0 和 ...","head":[["meta",{"property":"og:url","content":"https://mister-hope.github.io/dbs/Redis.html"}],["meta",{"property":"og:site_name","content":"CODER LIANG"}],["meta",{"property":"og:title","content":"Redis"}],["meta",{"property":"og:description","content":"Redis 一、介绍 关系型数据库 和 非关系型数据库 关系型数据库：MySQL Oracle .. 特点：数据结构严谨（库，表，字段..），插入数据严格符合声明的数据类型。 ACID：原子性，一致性，独立性，持久性 非关系型数据库：Redis Hbase ... 特点：数据结构不严谨、松散， CAP：强一致性，可用性，分区容错性 WEB 1.0 和 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://tva1.sinaimg.cn/large/008eGmZEly1gogaxmz18bj30kb0f0jsr.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"Coder Liang"}],["meta",{"property":"article:tag","content":"SQL"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Redis\\",\\"image\\":[\\"https://tva1.sinaimg.cn/large/008eGmZEly1gogaxmz18bj30kb0f0jsr.jpg\\",\\"https://tva1.sinaimg.cn/large/008vxvgGly1h7rrry2hmtj30710gi0sy.jpg\\"],\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Coder Liang\\",\\"url\\":\\"https://blog.csdn.net/Phone_1070333541?type=blog\\"}]}"]]},"headers":[{"level":2,"title":"一、介绍","slug":"一、介绍","link":"#一、介绍","children":[]},{"level":2,"title":"二、数据类型","slug":"二、数据类型","link":"#二、数据类型","children":[]},{"level":2,"title":"三、连接池","slug":"三、连接池","link":"#三、连接池","children":[]},{"level":2,"title":"四、持久化","slug":"四、持久化","link":"#四、持久化","children":[]},{"level":2,"title":"五、Redis 单线程模型详解 (摘自Guide哥)","slug":"五、redis-单线程模型详解-摘自guide哥","link":"#五、redis-单线程模型详解-摘自guide哥","children":[]},{"level":2,"title":"六、redis集群","slug":"六、redis集群","link":"#六、redis集群","children":[]},{"level":2,"title":"七、Redis淘汰策略","slug":"七、redis淘汰策略","link":"#七、redis淘汰策略","children":[]},{"level":2,"title":"八、缓存穿透和缓存击穿","slug":"八、缓存穿透和缓存击穿","link":"#八、缓存穿透和缓存击穿","children":[]},{"level":2,"title":"九、先更新缓存还是先更新数据库？","slug":"九、先更新缓存还是先更新数据库","link":"#九、先更新缓存还是先更新数据库","children":[{"level":3,"title":"常见的策略有：","slug":"常见的策略有","link":"#常见的策略有","children":[]},{"level":3,"title":"cache aside","slug":"cache-aside","link":"#cache-aside","children":[]}]}],"git":{},"readingTime":{"minutes":8.81,"words":2643},"filePathRelative":"dbs/Redis.md","excerpt":"\\n<h2>一、介绍</h2>\\n<ol>\\n<li>\\n<h3>关系型数据库 和 非关系型数据库</h3>\\n<ul>\\n<li>\\n<h4>关系型数据库：MySQL   Oracle ..</h4>\\n<p>特点：数据结构严谨（库，表，字段..），插入数据严格符合声明的数据类型。</p>\\n<p>ACID：原子性，一致性，独立性，持久性</p>\\n</li>\\n<li>\\n<h4>非关系型数据库：Redis  Hbase ...</h4>\\n<p>特点：数据结构不严谨、松散，</p>\\n<p>CAP：强一致性，可用性，分区容错性</p>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<h3>WEB 1.0  和 WEB 2.0</h3>\\n<ul>\\n<li>\\n<h4>WEB 1.0</h4>\\n<p>用户大多情况只是浏览数据。</p>\\n</li>\\n<li>\\n<h4>WEB 2.0</h4>\\n<p>用户开始产生数据。这就产生了问题。</p>\\n<ul>\\n<li>\\n<p>高并发：同一时刻多个用户往数据库插入数据。</p>\\n</li>\\n<li>\\n<p>海量数据：存储大量数据。</p>\\n</li>\\n<li>\\n<p>高扩展性与可用性：服务器切换方式 与 停机时间 。</p>\\n</li>\\n</ul>\\n</li>\\n</ul>\\n</li>\\n<li>\\n<h3>NoSQL ：not only sql</h3>\\n</li>\\n<li>\\n<h3>特性</h3>\\n<ul>\\n<li>\\n<h4>多数据库。（默认16个 [ 0~15 ])</h4>\\n<p>select  库索引  可以选择数据库存数据。</p>\\n<p>dbsize  查看当前数据库长度</p>\\n<p>flush  删除数据库内容</p>\\n</li>\\n<li>\\n<h4>消息的订阅与发布</h4>\\n<p>subscribe  订阅关键字 （完全匹配）</p>\\n<p>public 发布  键   值</p>\\n<p>psubscribe  订阅关键字（关键字匹配）</p>\\n</li>\\n</ul>\\n</li>\\n</ol>","autoDesc":true}');export{c as comp,o as data};
